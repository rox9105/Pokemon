[{"C:\\Users\\Ram\\Desktop\\pokedex\\src\\index.js":"1","C:\\Users\\Ram\\Desktop\\pokedex\\src\\App.js":"2","C:\\Users\\Ram\\Desktop\\pokedex\\src\\reportWebVitals.js":"3","C:\\Users\\Ram\\Desktop\\pokedex\\src\\reduxStore\\reduxStore.js":"4","C:\\Users\\Ram\\Desktop\\pokedex\\src\\reduxStore\\mainReducer.js":"5","C:\\Users\\Ram\\Desktop\\pokedex\\src\\header\\Header.jsx":"6","C:\\Users\\Ram\\Desktop\\pokedex\\src\\mainPage\\MainPageContainer.jsx":"7","C:\\Users\\Ram\\Desktop\\pokedex\\src\\mainPage\\pokemon\\PokemonContainer.jsx":"8","C:\\Users\\Ram\\Desktop\\pokedex\\src\\localStorage\\localStorage.js":"9","C:\\Users\\Ram\\Desktop\\pokedex\\src\\mainPage\\MainPage.jsx":"10","C:\\Users\\Ram\\Desktop\\pokedex\\src\\mainPage\\pokemon\\Pokemon.jsx":"11"},{"size":520,"mtime":1611836198768,"results":"12","hashOfConfig":"13"},{"size":554,"mtime":1611843679508,"results":"14","hashOfConfig":"13"},{"size":362,"mtime":499162500000,"results":"15","hashOfConfig":"13"},{"size":454,"mtime":1614265367419,"results":"16","hashOfConfig":"13"},{"size":6669,"mtime":1614327012896,"results":"17","hashOfConfig":"13"},{"size":358,"mtime":1611926066556,"results":"18","hashOfConfig":"13"},{"size":2445,"mtime":1614254196906,"results":"19","hashOfConfig":"13"},{"size":442,"mtime":1611843632830,"results":"20","hashOfConfig":"13"},{"size":481,"mtime":1613396052099,"results":"21","hashOfConfig":"13"},{"size":11410,"mtime":1614269258106,"results":"22","hashOfConfig":"13"},{"size":2657,"mtime":1614264115281,"results":"23","hashOfConfig":"13"},{"filePath":"24","messages":"25","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},"16nmy8t",{"filePath":"27","messages":"28","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"29","messages":"30","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"33","messages":"34","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"35","messages":"36","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"43","messages":"44","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"45","usedDeprecatedRules":"26"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},"C:\\Users\\Ram\\Desktop\\pokedex\\src\\index.js",[],["48","49"],"C:\\Users\\Ram\\Desktop\\pokedex\\src\\App.js",[],"C:\\Users\\Ram\\Desktop\\pokedex\\src\\reportWebVitals.js",[],"C:\\Users\\Ram\\Desktop\\pokedex\\src\\reduxStore\\reduxStore.js",[],"C:\\Users\\Ram\\Desktop\\pokedex\\src\\reduxStore\\mainReducer.js",[],"C:\\Users\\Ram\\Desktop\\pokedex\\src\\header\\Header.jsx",[],"C:\\Users\\Ram\\Desktop\\pokedex\\src\\mainPage\\MainPageContainer.jsx",[],"C:\\Users\\Ram\\Desktop\\pokedex\\src\\mainPage\\pokemon\\PokemonContainer.jsx",[],"C:\\Users\\Ram\\Desktop\\pokedex\\src\\localStorage\\localStorage.js",[],"C:\\Users\\Ram\\Desktop\\pokedex\\src\\mainPage\\MainPage.jsx",["50","51"],"import React, { useState } from 'react'\r\nimport { NavLink } from 'react-router-dom'\r\nimport s from './MainPage.module.css'\r\nimport alt_P_Icon from '../assets/alt_P_Icon.bmp'\r\n\r\nconst MainPage = (props) => {\r\n    let [sliceBegin, setSliceBegin] = useState(+props.currentPage >= 3 ? +props.currentPage - 3 : 0)\r\n    let [sliceEnd, setSliceEnd] = useState(+props.currentPage >= 3 ? +props.currentPage + 2 : 5)\r\n    let [isDisabled, setIsDisabled] = useState(false)\r\n\r\n    React.useEffect(() => {\r\n        localStorage.setItem('pageSize', JSON.stringify(props.pageSize))\r\n    })\r\n\r\n    let pagesArrayLocal = []\r\n    let pagesCount = props.totalCount / props.pageSize\r\n    for (let i = 1; i <= Math.ceil(pagesCount); i++)\r\n        pagesArrayLocal.push(i)\r\n\r\n    React.useEffect(() => {\r\n        pagesCount = props.totalCount / props.pageSize\r\n        pagesArrayLocal = new Array(Math.ceil(pagesCount)).fill().map((_, i) => i + 1)\r\n        if (pagesArrayLocal.length >= 1 || props.pages === null) {\r\n            props.setPages(pagesArrayLocal)\r\n        }\r\n    }, [props.pageSize, props.totalCount])\r\n\r\n    let showNextPageBut = () => {\r\n        setSliceBegin(sliceBegin + 1)\r\n        setSliceEnd(sliceEnd + 1)\r\n    }\r\n    let showPreviousPageBut = () => {\r\n        if (sliceBegin > 0) { setSliceBegin(sliceBegin - 1) }\r\n        if (sliceEnd > 5) { setSliceEnd(sliceEnd - 1) }\r\n    }\r\n    let onChangePage = (event) => {\r\n        let pageNumber = event.target.value\r\n        let offset = pageNumber * props.pageSize - props.pageSize\r\n        let pageSize = props.pageSize\r\n        props.setCurrentPage(+pageNumber)\r\n        props.getPokemons(pageSize, offset)\r\n        funcDisableTimer()\r\n    }\r\n    let goToPreviousPage = () => {\r\n        props.getInotherPage(props.state.previousPage)\r\n        props.setCurrentPage((props.currentPage - 1))\r\n        showPreviousPageBut()\r\n        funcDisableTimer()\r\n    }\r\n    let goToNextPage = () => {\r\n        props.getInotherPage(props.state.nextPage)\r\n        props.setCurrentPage((props.currentPage + 1))\r\n        showNextPageBut()\r\n        funcDisableTimer()\r\n    }\r\n    let goToFirstPage = () => {\r\n        if (props.currentPage !== 1) {\r\n            props.getPokemons(props.pageSize)\r\n            props.setCurrentPage(1)\r\n            setSliceBegin(0)\r\n            setSliceEnd(5)\r\n        }\r\n    }\r\n    let goToLastPage = () => {\r\n        if (props.currentPage !== props.pages.length) {\r\n            let pageNumber = props.pages.length\r\n            let offset = pageNumber * props.pageSize - props.pageSize\r\n            let pageSize = props.pageSize\r\n            props.getPokemons(pageSize, offset)\r\n            props.setCurrentPage(pageNumber)\r\n            setSliceBegin(pageNumber - 5)\r\n            setSliceEnd(pageNumber)\r\n        }\r\n    }\r\n    let funcDisableTimer = () => {\r\n        setIsDisabled(true)\r\n        console.log(isDisabled)\r\n        setTimeout(() => {\r\n            setIsDisabled(false)\r\n        }, 1000)\r\n    }\r\n    let pageSizeButtonsArray = [\r\n        { value: 5 },\r\n        { value: 10 },\r\n        { value: 20 },\r\n    ]\r\n    let onChangePageSize = (event) => {\r\n        let pageSize = event.target.value\r\n        props.setPageSize(pageSize)\r\n        props.setPages(props.pages)\r\n        props.setCurrentPage(1)\r\n        if (props.state.pageSize === pageSize && props.pokemons.length === +props.state.pageSize) { }\r\n        else {\r\n            props.getPokemons(pageSize)\r\n            setSliceBegin(0)\r\n            setSliceEnd(5)\r\n        }\r\n    }\r\n    let setValueForSearching = (event) => {\r\n        let value = event.target.value\r\n        props.setText(value)\r\n    }\r\n    let searchPokemons = () => {\r\n        let result = props.pokemonsToSearch.filter(el => el.name.includes(props.textToSearch))\r\n        if (props.textToSearch.length >= 2) {\r\n            props.setText('')\r\n            props.setType('')\r\n            props.setCurrentPage(1)\r\n            props.setNextPage(null)\r\n            props.setPreviousPage(null)\r\n            props.setPages(0)\r\n            props.searchingPokemons(result)\r\n        }\r\n        if (result.length <= 0) {\r\n            props.setPokemons(0)\r\n        }\r\n    }\r\n    let setPType = (e) => {\r\n        let type = e.target.value\r\n        props.setType(type)\r\n        props.setPages(0)\r\n        props.setNextPage(null)\r\n        props.setPreviousPage(null)\r\n        if (type === '') { props.getPokemons(props.pageSize) }\r\n        else { props.getPokemonsByType(type) }\r\n    }\r\n    let setDefaultType = () => {\r\n        props.setType('')\r\n        if (props.pokemons.length !== parseInt(props.pageSize)) {\r\n            props.setPages(pagesArrayLocal);\r\n            props.setCurrentPage(1)\r\n            props.getPokemons(props.pageSize)\r\n            setSliceBegin(0)\r\n            setSliceEnd(5)\r\n        }\r\n    }\r\n    let reloadPage = () => {\r\n        props.setText('')\r\n        props.setType('')\r\n        props.setPages(pagesArrayLocal)\r\n        props.setCurrentPage(1)\r\n        setSliceBegin(0)\r\n        setSliceEnd(5)\r\n        props.getPokemons(props.pageSize)\r\n    }\r\n    let currentPage = props.state.currentPage\r\n\r\n    return (\r\n        <div className={s.contentMainBlock}>\r\n            <div className={s.paginationBlock}>\r\n                <span className={s.inotherPageText}>Go to inother page : </span>\r\n                <button disabled={+props.currentPage === 1 ? true : false || isDisabled}\r\n                    className={s.pageBtnsFirstLast} onClick={goToFirstPage}>first</button>\r\n                <button disabled={props.state.previousPage === null\r\n                    || props.type !== '' ? true : false || isDisabled}\r\n                    className={s.btnsNextPrev} onClick={goToPreviousPage}>prev</button>\r\n                {props.pages !== null && props.pages !== 0 && props.pages.slice(sliceBegin, sliceEnd)\r\n                    .map(p =>\r\n                        <button value={p} key={p} onClick={onChangePage}\r\n                            disabled={+currentPage === +p ? true : false || isDisabled}\r\n                            className={currentPage === p ? s.selectedButton : s.paginationButtons}>\r\n                            {p}\r\n                        </button>\r\n                    )}\r\n                <button disabled={props.state.nextPage === null ? true : false || isDisabled}\r\n                    className={s.btnsNextPrev} onClick={goToNextPage}>next</button>\r\n                <button disabled={+props.pageSize !== +props.pokemons.length ? true : false || isDisabled}\r\n                    className={s.pageBtnsFirstLast} onClick={goToLastPage}>last</button>\r\n            </div>\r\n            <div className={s.changePageSizeBlock}>\r\n                <span className={s.pokPerPageText}>Pokemons per page : </span>\r\n                {pageSizeButtonsArray.map(el =>\r\n                    <button value={el.value} key={el.value} onClick={onChangePageSize}\r\n                        className={\r\n                            +props.pageSize === +el.value ? s.changePSizeBtnsActive : s.changePSizeBtns}\r\n                        disabled={+el.value === +props.pageSize ? true : false || isDisabled} >\r\n                        {el.value}\r\n                    </button>\r\n                )}\r\n                <span className={s.pokAtMomentText}>\r\n                    Pokemons at the moment :\r\n                    <span className={s.pokAtMomentNumber}>\r\n                        {props.pokemons.length}\r\n                    </span>\r\n                </span>\r\n            </div>\r\n            <div className={s.searchingBlock}>\r\n                <span className={s.searchByNameText}>Search by name : </span>\r\n                <div className={s.searchByTextBlock}>\r\n                    <input className={s.inputSearch} placeholder={'minimum two letters...'}\r\n                        onChange={setValueForSearching} value={props.textToSearch} />\r\n                    <button onClick={searchPokemons} className={s.buttonSearch}>Search</button>\r\n                    <button onClick={reloadPage} className={s.buttonReload}>Reload</button>\r\n                </div>\r\n                <div className={s.searchByTypeBlock} style={{ display: 'inline' }}>\r\n                    <span className={s.searchByTypeText}>Search By Type : </span>\r\n                    <select className={s.selectType} onChange={setPType} value={props.currentType}>\r\n                        <option className={s.optionTypeAll} disabled={true} value=''>All Types</option>\r\n                        <option className={s.optionTypeFighting} value={'fighting'}>Fighting</option>\r\n                        <option className={s.optionTypeIce} value={'ice'}>Ice</option>\r\n                        <option className={s.optionTypeDark} value={'dark'}>Dark</option>\r\n                        <option className={s.optionTypeGround} value={'ground'}>Ground</option>\r\n                        <option className={s.optionTypeGhost} value={'ghost'}>Ghost</option>\r\n                        <option className={s.optionTypeDragon} value={'dragon'}>Dragon</option>\r\n                        <option className={s.optionTypeRock} value={'rock'}>Rock</option>\r\n                        <option className={s.optionTypeSteel} value={'steel'}>Steel</option>\r\n                        <option className={s.optionTypeBug} value={'bug'}>Bug</option>\r\n                        <option className={s.optionTypeFire} value={'fire'}>Fire</option>\r\n                        <option className={s.optionTypePoison} value={'poison'}>Poison</option>\r\n                        <option className={s.optionTypeGrass} value={'grass'}>Grass</option>\r\n                    </select>\r\n                    <button onClick={setDefaultType} className={s.clearSearchButton}>X</button>\r\n                </div>\r\n            </div>\r\n            <div className={s.pokemonsBlock}>\r\n                {props.pokemons === 0 || null\r\n                    ?\r\n                    <div className={s.errorNoResults}>\r\n                        <span className={s.errMessage}>\r\n                            No results, please try again\r\n                        </span>\r\n                    </div>\r\n                    :\r\n                    props.pokemons.filter(el => el !== undefined || null).map(el =>\r\n                        <NavLink to={`/pokemon?id=` + el.name} key={el.id}>\r\n                            <div className={s.loadedPokemonsBlock} key={el.id}>\r\n                                <img src={el.sprites.front_default || alt_P_Icon}\r\n                                    className={s.pIcon} alt='img' />\r\n                                <div className={s.pokemonsInfoValues}>\r\n                                    <div className={s.textName}>Name</div>\r\n                                    <div className={s.pokemonsStats1}>{el.name}</div>\r\n                                    <div className={s.pokemonsStats2}>Base Exp : {el.base_experience}</div>\r\n                                    <div className={s.pokemonsStats3}>Height : {el.height}</div>\r\n                                    <div className={s.pokemonsStats4}>Weight : {el.weight}</div>\r\n                                </div>\r\n                                {el.types.map(t =>\r\n                                    <div className={s.pTypes} key={t.type.url}>{t.type.name}</div>)}\r\n                            </div>\r\n                        </NavLink>\r\n                    )\r\n                }\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default MainPage","C:\\Users\\Ram\\Desktop\\pokedex\\src\\mainPage\\pokemon\\Pokemon.jsx",[],{"ruleId":"52","replacedBy":"53"},{"ruleId":"54","replacedBy":"55"},{"ruleId":"56","severity":1,"message":"57","line":21,"column":22,"nodeType":"58","endLine":21,"endColumn":55},{"ruleId":"56","severity":1,"message":"59","line":22,"column":27,"nodeType":"60","endLine":22,"endColumn":87},"no-native-reassign",["61"],"no-negated-in-lhs",["62"],"react-hooks/exhaustive-deps","Assignments to the 'pagesCount' variable from inside React Hook React.useEffect will be lost after each render. To preserve the value over time, store it in a useRef Hook and keep the mutable value in the '.current' property. Otherwise, you can move this variable directly inside React.useEffect.","BinaryExpression","Assignments to the 'pagesArrayLocal' variable from inside React Hook React.useEffect will be lost after each render. To preserve the value over time, store it in a useRef Hook and keep the mutable value in the '.current' property. Otherwise, you can move this variable directly inside React.useEffect.","CallExpression","no-global-assign","no-unsafe-negation"]